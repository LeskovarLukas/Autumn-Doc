\chapter{Path Planning}

\textbf{Author: Fabian Kleinrad} 

A crucial part of autonomy in robotics are means for planning ahead movements in a cooperative manner with the environment. Means to accomplish this are so called path planning algorithms. This chapter is going to focus on exploring the different kind of approaches to path planning and evaluate which approach is most fitting to be used in a real-time, high-dimensional use case present in the Autumn project.


\section{Types of Path Planning}

The problem of finding an optimal path between two points is an old one.
The first proposed solution was the Dijkstra's Algorithm. However with steadily evolving computer science the challenges to be master by such Algorithms got harder and harder. That's the reason why over the last years the simple principle of the Dijkstra Algorithm has branched out specializing and excelling in certain real world applications.
\footcite{Pan2020}

\subsection{Sampling-based Algoritms}

In motion planning Sampling-based Algorithms can be differentiated to other kinds of approaches, by the way they explore their environment. Sampling-based Algorithms such as the Probabilistic Road Map Algorithm or the Rapidly exploring Random Tree use a random point in their reference space and expand in that direction. This random point is considered a sample.

\subsection{Multiple-Query and Single-Query}

The term Multiple-Query refers, in connection with path planning Algorithms, to the feasibility of deriving variety of different paths, without the need of rerunning the algorithm. In Contrast Single-Query Algorithms are only able to compute one path at a time.\newline
Use cases for Multiple-Query Algorithms would be unchanging environments. The reason for that, by generating an extensive grid of connections to be able to calculate a multitude of different start/goal combinations  more computational time is needed.\newline
Single-Query approaches focus on performance instead of reuse-ability, which makes them ideal for dynamic domains. 
\footcite{Bekris2003}
\footcite{stackexchangeMultiSingleQuery2019}

\section{PRM}

Probabilistic RoadMap is a path planning algorithm tailored to multi-query application. It is considered one of the most influential sampling-based path planning algorithms. 

The algorithm can be broken down into two phases. The first phase, which is referred to as the pre-processing phase, starts with an empty graph. At first it samples n random points and adds them to a set of vertices, if they are located in space free from obstacles. After constructing a set of n vertices, it attempts connections between a random vertex and it's neighboring nodes in a predefined radius. This connecting of to vertices is realized with a simple straight line connection. All collision free connections between vertices and their respective neighbors are added to a set of edges. The result of this pre-processing phase is a roadmap, with the number of sampled points determining the quality of to be calculated paths. 
\footcite{Karaman2011}

Upon finishing the initial construction phase of a roadmap, like the one depicted in figure 8.1, start/goal combinations can be processed. 
The actual path finding in the generated graph is handled by other non-sampling-based path finding methods such as A*.\newline
With the PRM focusing on a multi-query approach it is possible to calculate a arbitrary number of different paths without the need to construct a new graph.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{img/PRMRoadmap}
	\caption{Example of a roadmap in two dimensional space constructed by the PRM algorithm.}
	\label{fig:path_planning_prm}
\end{figure}

\section{RRT Algorithm}

Rapidly exploring random tree is a path planning algorithm, that can be categorized as sampling-based and single-query. In the field of sampling-based path finding algorithms is it considered together with the PRM the most influential. RRT works by constructing a tree of possible trajectories. Therefore it is first required to define an initial vertex, much like a root. After each following iteration a random sample is taken from the space that is considered free from obstacles. After generating a random vertex, the nearest neighboring point in the tree is search for. The closest node is than used as a pivot point and a new vertex is constructed a predefined distance away from the nearest node in the direction of the random sample. Thereafter it is attempted to connect the new vertex with the nearest. If this straight-line connection can exits without colliding with obstacles it is added to the set of edges. This procedure is depicted in figure 8.2. The algorithm end when a new node is within the predefined distance away from the goal point. 
\footcite{Karaman2011}

The name rapidly exploring random tree stems from the tree like structure constructed, like the one you can see in figure 8.2, when exploring spaces This approach to path planning makes it possible to explore rapidly changing environments efficiently.


\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{img/rrtIteration}
	\caption{Visualization of the first two iterations (a), (b) when an rrt algorithm is exploring a simple 2d space wihttps://robotics.stackexchange.com/questions/18433/difference-between-single-query-and-multiple-query-algorithmsth an obstacle present. D referring to the predefined distance between vertices.\footcite{Zammit2018}}
	\label{fig:path_planning_rrt}
\end{figure}

\section{A* Algorithm}

The A* algorithm is a simplistic and reliable method compared to other path-planning techniques. Therefor it is nowadays prevalently used in a variety of different applications.\footcite{Zammit2018}\newline
It combines heuristic properties with formal virtues of the Dijkstra's algorithm. Whereas a purely heuristic approach would not guarantee that a path can be found even if a possible solution existed, the A* guarantees that the shortest path is found.\footcite{Sathyaraj2008}
A* works by trying all possible combinations like the Dijkstra algorithm in a grid or graph based environment. With A* being based on the Dijkstra algorithm it favors nodes that are closer to the current position. Additionally it follows heuristic principles by putting a higher priority on nodes closer to the goal. An example of what an A* search algorithm looks like in a grid based environment is depicted in figure 8.3.\footcite{standfordAStarComparison1997}\newline
With these properties it can be considered a informed Dijkstra search.
  
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{img/AStarExample}
	\caption{A* path finding around a concave obstacle in a grid-based environment.\footcite{standfordAStarComparison1997}}
	\label{fig:path_planning_Astar}
\end{figure}

\section{Evaluation}

\subsection{Autumn Use-case}

There are a number of criteria to be fulfilled, in order to be considered a working solution for the challenge of path planning faced by Autumn.
As a means to using one of the aforementioned algorithms, they have to be suitable for a real-time, 3-dimensional application, like the one present in the project.
When working with UAVs it is critical that an optimal path is calculated reliable and in a shortest amount of time possible. 

\subsection{Comparison}

In the following comparison we are going to look at the performance of the three different algorithms already mentioned in this chapter. Knowing that the PRM algorithm doesn't find a path on it's own, it is implied from here on out that the PRM works in combination with the A* algorithm and the A* on its own is only applied with grid-based environments.  

\subsubsection{real-time feasibility}

When talking about real-time in the Autumn project one understands it as being able to process a path, in a complex environment in an effort for the UAV to be able to continually stay in motion without any risk of colliding with obstacles. 

\subsubsection{high dimensions}

\section{RRT* Algorithm}

\subsection{Concept behind RRT*}

\subsection{Implementation in Autumn}

\section{RRT* Variants}

\subsection{RT-RRT*}

The RT-RRT* takes big focus in real-time path planning. RT-RRT* makes it possible to reposition the root node. Using this online tree rewiring strategy it makes it possible to keep the previously sampled tree.
The two core principles introduced with the RT-RRT*, are tree expansion and tree rewiring. 
At first the Algorithm start by initializing a root node. After each following iterations the tree expands and rewires. This sampling last for a user-defined time and is followed by planning a path from the root. The length of this path is controlled by the user, by defining the amount of steps the path consists of. In this phase the agent is moved gradually towards the tree root. Thereafter, when path planning is finished an the agent is located at the position of the tree root, the position of the root is changed to the next node in the generated path. With this approach it enables the agent to move without the time needed to compute the whole path.
Expansion in the RT-RRT* is done similar to the base algorithm, by sampling a random node, finding its neighbor with the minimum cost-to-reach and connecting them.
The rewiring is done in the default scenario done, because of newly added nodes having a smaller cost-to-reach than the parent of a certain node. In the second case rewiring is needed if the environment changes. Therefor a lager portion of the tree has to change. Hereby two different modes are utilized. The first one consisting of rewiring the tree in a circle centered around the tree node. For the second option both focused and uniform sampling are used, with the difference that it is not done for one node, but instead concentrates on patches.
\footcite{Naderi2015}

\subsubsection{RT-RRT* in Autumn}

When applying the concept of the RT-RRT* to Autumn it would seem a good idea. Taking a closer look uncovers that the proposed RT-RRT* only works efficiently in environments with limited changes. Rewiring the tree, done in the case of an dynamic obstacle changing, doesn't make sense when the obstacle referred to covers a large portion of the space. With this being the case in Autumn, because contrary to the examples in the paper covering the RT-RRT* is the algorithm not educated about the environment. Only while moving are obstacles and boundaries discovered In general the RT-RRT* is using concepts of roadmaps like the one generated in the PRM algorithm and applying it to the RRT* algorithm.  

\subsection{Smart-RRT*}

Smart-RRT* focuses on solving the problem imposed when using the RRT* algorithm. With the slow convergence rate of the RRT* towards an ideal path, it takes up to an infinite amount of time to reach the most optimal path. Therefor Smart-RRT* utilizes two techniques, path optimization and intelligent sampling, in an effort of accelerating the rate of convergence. 
It works the same as the base algorithm till the first path is found. From there on out it applies path optimization and intelligent sampling. Path optimization works by interconnecting nodes in the found path that are directly visible. This leads based on triangular inequality to an shorter path. The reconnected nodes are than used as biased points for intelligent sampling. Intelligent sampling samples new points based on a bias generated from finding a shorter path. Resulting is a greater node density in the area of critical points on the path, mostly located around obstacles. 
\footcite{Islam2012}

\subsubsection{Smart-RRT* in Autumn}
Using Smart-RRT* improves the rate of convergence and time to reach an optimal path drastically. Which makes one ponder why not use this improved version of the implemented algorithm in the project. When looking at this it is important to keep the goal in mind the autumn project aims to reach. Which is, to capture an environment in form of a 3 dimensional model. Therefor it is unnecessary to compute an optimal path. The whole space is going to be covered eventually which would only be a waste of computational power to invest in additional path optimization. 